import logging
from issue_iterator import SonarQubeConfig, SonarQubeIssueIterator
import boto3

class FixGenerator:
    """
    A class to generate fixes for SonarQube issues using AWS Bedrock.
    """

    def __init__(self, sonarqube_config, aws_access_key, aws_secret_key, aws_region, bedrock_model_id, logger=None):
        """
        Initialize the FixGenerator.

        Args:
            sonarqube_config (SonarQubeConfig): Configuration for SonarQube.
            aws_access_key (str): AWS access key for Bedrock.
            aws_secret_key (str): AWS secret key for Bedrock.
            aws_region (str): AWS region for Bedrock.
            bedrock_model_id (str): Model ID to use with AWS Bedrock.
            logger (logging.Logger): Logger instance.
        """
        self.sonarqube_config = sonarqube_config
        self.aws_region = aws_region
        self.bedrock_model_id = bedrock_model_id
        self.logger = logger or logging.getLogger(__name__)
        self.iterator = SonarQubeIssueIterator(sonarqube_config, logger=self.logger)
        self.bedrock_client = boto3.client(
            'bedrock',
            aws_access_key_id=aws_access_key,
            aws_secret_access_key=aws_secret_key,
            region_name=aws_region
        )

    def generate_fix(self, issue):
        """
        Generate a fix for a specific SonarQube issue using AWS Bedrock.

        Args:
            issue (dict): Details of the SonarQube issue.

        Returns:
            str: Git patch generated by Bedrock.
        """
        prompt = self._create_prompt(issue)
        response = self._send_to_bedrock(prompt)
        return self._extract_patch_from_response(response)

    def _create_prompt(self, issue):
        """
        Create a Bedrock prompt for the given issue.

        Args:
            issue (dict): Details of the SonarQube issue.

        Returns:
            str: Prompt to send to Bedrock.
        """
        return f"""
        You are a coding assistant. Analyze the following SonarQube issue and generate a fix in the form of a Git patch.

        Issue details:
        - Key: {issue.get('key')}
        - Severity: {issue.get('severity')}
        - Message: {issue.get('message')}
        - Component: {issue.get('component')}
        - Line: {issue.get('line')}

        Please provide the fix as a valid Git patch.
        """

    def _send_to_bedrock(self, prompt):
        """
        Send the prompt to AWS Bedrock and get the response.

        Args:
            prompt (str): Prompt to send to Bedrock.

        Returns:
            dict: Response from Bedrock.
        """
        response = self.bedrock_client.invoke_model(
            modelId=self.bedrock_model_id,
            inputText=prompt
        )
        return response

    def _extract_patch_from_response(self, response):
        """
        Extract the Git patch from the Bedrock response.

        Args:
            response (dict): Response from Bedrock.

        Returns:
            str: Extracted Git patch.
        """
        return response.get("outputText", "").strip()

    def process_issues(self):
        """
        Process all SonarQube issues and generate fixes for them.

        Returns:
            dict: A dictionary mapping issue keys to their generated Git patches.
        """
        fixes = {}
        try:
            for issue in self.iterator:
                self.logger.info(f"Processing issue {issue.get('key')}")
                try:
                    patch = self.generate_fix(issue)
                    fixes[issue.get('key')] = patch
                    self.logger.info(f"Generated patch for issue {issue.get('key')}")
                except Exception as e:
                    self.logger.error(f"Error generating fix for issue {issue.get('key')}: {str(e)}")
        except Exception as e:
            self.logger.error(f"Error iterating through issues: {str(e)}")
        return fixes